---
layout:     post
title:      "ES6-review"
subtitle:   "ES6知识点温习"
date:       2018-02-05 16:30:00
author:     "Mickey"
header-img: "img/post-bg-os-metro.jpg"
tags:
    - 前端开发
    - javaScript
---

一年前，系统学习过一次ES6语法，随着时间的推移，记忆有些模糊，加之一年的工作产出了一些沉淀，因此，准备温习一遍，记录一下新的体会，参考书籍为阮一峰老师的[ECMAScript 6 入门](http://es6.ruanyifeng.com/)，感谢🙏

* 在ES5中，var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined，为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错

	```js
	// var 的情况
	console.log(foo); // 输出undefined
	var foo = 2;
	
	// let 的情况
	console.log(bar); // 报错ReferenceError
	let bar = 2;
	```
	
* const命令只是限制变量对应的地址不可改变，但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了，如果真的想将对象冻结，应该使用Object.freeze方法

	```js
	const foo = {};

	// 为 foo 添加一个属性，可以成功
	foo.prop = 123;
	foo.prop // 123
	
	// 将 foo 指向另一个对象，就会报错
	foo = {}; // TypeError: "foo" is read-only
	
	var constantize = (obj) => {
	  Object.freeze(obj);
	  Object.keys(obj).forEach( (key, i) => {
	    if ( typeof obj[key] === 'object' ) {
	      constantize( obj[key] );
	    }
	  });
	};
	```

* 解构赋值的默认值，只有在原本赋值不存在或者===undefined的情况下，才会使用默认赋值，例如，原本赋值为null，解构赋值也不会采用默认值

	```js
	let [x, y = 'b'] = ['a']; // x = 'a', y = 'b'
	let [x, y = 'b'] = ['a', undefined]; // x = 'a', y = 'b'
	let [x, y = 'b'] = ['a', null]; // x = 'a', y = null
	```

* js中，可以用'\u0061'表示Unicode码形式，但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示，ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符

	```js
	"\u0061" // "a"
	"\uD842\uDFB7" // "𠮷"
	"\u20BB7" // " 7"
	"\u{20BB7}" // "𠮷"
	```

* ES5中提供charCodeAt和String.fromCodeAt来进行码点和对应字符的转换，但是这两个api不能识别 32 位的 UTF-16 字符，ES6新增了codePointAt和String.fromPointAt两个API，需要注意的是，两个API分别是挂在字符串对象和String上的。codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符

	```js
	var s = "𠮷a";
	s.charCodeAt(0) // 55362
	s.charCodeAt(1) // 57271
	s.codePointAt(0) // 134071
	s.codePointAt(1) // 57271
	s.codePointAt(2) // 97
	String.fromCharCode(0x20BB7) // "ஷ"
	String.fromCodePoint(0x20BB7) // "𠮷"
	let s = '𠮷a';
	for (let ch of s) {
	  console.log(ch.codePointAt(0).toString(16));
	}
	// 20bb7
	// 61
	```

* ES6字符串提供一个repeat()方法，将原字符串重复n次

	```js
	'x'.repeat(3) // "xxx"
	'hello'.repeat(2) // "hellohello"
	'na'.repeat(0) // ""
	'na'.repeat(2.9) // "nana"
	```
	
* ES2017引入了字符串补全长度的功能，我个人觉得这个功能非常有用，如果某个字符串不够指定长度，会在头部或尾部补全，padStart()用于头部补全，padEnd()用于尾部补全

	```js
	'x'.padStart(5, 'ab') // 'ababx'
	'x'.padStart(4, 'ab') // 'abax'
	
	'x'.padEnd(5, 'ab') // 'xabab'
	'x'.padEnd(4, 'ab') // 'xaba'
	```
	
* ES6新增了识别大于\uFFFF字符的方法，对应的，在正则表达式中新增了一个u的flags，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符，也就是说，会正确处理四个字节的 UTF-16 编码

	```js
	/^\uD83D/u.test('\uD83D\uDC2A') // false
	/^\uD83D/.test('\uD83D\uDC2A') // true
	```

* ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。
y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义

	```js
	var s = 'aaa_aa_a';
	var r1 = /a+/g;
	var r2 = /a+/y;
	
	r1.exec(s) // ["aaa"]
	r2.exec(s) // ["aaa"]
	
	r1.exec(s) // ["aa"]
	r2.exec(s) // null
	```

* 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character），`ES2018` 引入s修饰符，使得.可以匹配任意单个字符

* 正则表达式具名组匹配，在ES5中，正则表达式使用圆括号进行组匹配，组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号，`ES2018`引入了具名组匹配，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用，如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k<组名>的写法，类似于\1的写法，这两种写法可以兼容一起使用

	```js
	const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

	const matchObj = RE_DATE.exec('1999-12-31');
	const year = matchObj[1]; // 1999
	const month = matchObj[2]; // 12
	const day = matchObj[3]; // 31
	
	const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

	const matchObj = RE_DATE.exec('1999-12-31');
	const year = matchObj.groups.year; // 1999
	const month = matchObj.groups.month; // 12
	const day = matchObj.groups.day; // 31

	const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
	RE_TWICE.test('abc!abc!abc') // true
	RE_TWICE.test('abc!abc!ab') // false
	```